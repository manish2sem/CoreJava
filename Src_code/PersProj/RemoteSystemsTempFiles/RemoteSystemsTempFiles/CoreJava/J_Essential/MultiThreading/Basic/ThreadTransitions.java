package CoreJava.J_Essential.MultiThreading.Basic;

/*
 * A thread can be only in one of five states : 
 * New - Thread instance has been created, but the start() method has not been invoked, thread is considered not alive.
 * Runnable - Thread is eligible to run, start() method is invoked but the scheduler has not selected it to be the running thread. 
 * A thread can also return to the runnable state after either running or coming back from a blocked, waiting, or sleeping state. Thread is considered alive.
 * Running - the scheduler chooses a thread from the runnable pool and thread become the currently executing process.
 * Dead - A thread is considered dead when its run() method completes. If you invoke start() on a dead Thread 
 * instance, you'll get a runtime (not compiler) exception.
 * Waiting/blocked/sleeping - the thread is still alive, but is currently not eligible to run i.e. it is not runnable, but it might 
 * return to a runnable state later if a particular event occurs.
 * A thread may be blocked waiting for a resource (like I/O or an object's lock), in which case the event that sends it back to runnable is the availability of the resource
 * A thread may be sleeping because the thread's run code tells it to sleep for some period of time, 
 * in which case the event that sends it back to runnable is that it wakes up because its sleep time has expired
thread may be waiting, because the
thread's run code causes it to wait, in which case the event that sends it back
to runnable is that another thread sends a notification that it may no longer
be necessary for the thread to wait.
 */

public class ThreadTransitions {

}
